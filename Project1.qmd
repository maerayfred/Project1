---
title: "Project1"
format: html
editor: source
---

## Data Processing

### In this step, we create the URL string, starting with the base URL and incorporating our default variables from get_vals. We set a default geography of state 10 (Delaware) to prevent unintended large API calls.

```{r}
#| file: "src/census_query.R"
```

```{r}
#| file: "test/test_census_query.R"
```


```{r}
test_1_cq()
test_2_cq()
test_3_cq()
test_4_cq()
```

### We're creating a function to access API data, allowing the year to change with a default of 2022, along with a list of valid variables for the PUMS API. We're accessing all valid API variables and subsetting them according to project instructions. We also create a function to check if the variables in the subset are numeric or character.

```{r}
#| file: "src/census_variables.R"
```

```{r}
#| file: "test/test_census_variables.R"
```

```{r}
str(tail(test_1_cv(), 3), max.level=4, list.len=6)
str(test_2_cv(), max.level = 4, list.len = 6)
test_3_cv()
test_4_cv()
test_5_cv()
```

### We're creating a function that matches valid variables with their corresponding numeric ranges and character items. 

```{r}
#| file: "src/input_validation.R"
```

```{r}
#| file: "test/test_input_validation.R"
```

```{r}
test_1_iv()
test_2_iv()
test_3_iv()
test_4_iv()
test_5_iv()
test_6_iv()
```


### TODO

```{r}
#| file: "src/post_processing.R"
```

```{r}
#| file: "test/test_post_processing.R"
```

```{r}
data_1_pp <- test_1_pp()
str(data_1_pp$data)
str(data_1_pp$var_info, max.level=2, list.len=5)
data_2_pp <- test_2_pp()
str(data_2_pp, max.level=2)
data_3_pp <- test_3_pp()
# doesnt have 0 in the int list anymore
head(table(data_3_pp$data$AGEP), 5)

data_4_pp <- test_4_pp()
str(data_4_pp$data)
str(data_4_pp$var_info, max.level=3, list.len=5)
```


### We're accessing all valid API variables and subsetting them according to project instructions. We also create a function to check if the variables in the subset are numeric or character. We're creating a function that matches valid variables with their corresponding numeric ranges and character items. We're processing time variables by separating the intervals, updating morning/evening abbreviations for usability, and calculating the midpoint to derive a single time point.

```{r}
#| file: "src/main.R"
```

```{r}
#| file: "test/test_main.R"
```

```{r}
data_1_m <- test_1_m()
data_1_m$URL
str(data_1_m$parsed)
data_2_m <- test_2_m()
str(data_2_m, max.level = 2)
```


### TODO

```{r}
#| file: "src/summarizing.R"
```

```{r}
#| file: "test/test_summarizing.R"
```

```{r}
test_1_s()
test_2_s()
```
